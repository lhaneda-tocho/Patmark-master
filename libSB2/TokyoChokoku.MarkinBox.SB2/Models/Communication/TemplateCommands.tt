<#@ template language="C#"#>
<#@ assembly name="System.Core"#>
<#@ output extension=".designer.cs" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="TokyoChokoku.MarkinBox.Sketchbook.MetaCommunication" #>
<#@ include file="$(SolutionDir)/Global.ttinclude"#>
<#  #>
// 
// This code is generated by "TemplateCommands.tt"
// Not allowed to modify this code because your changes are deleted when in regeration.
//


namespace TokyoChokoku.MarkinBox.Sketchbook.Communication {

    using System;
    using System.Linq;
	using System.Collections.Immutable;
	using System.Collections.Generic;
    using System.Threading.Tasks;

    public partial class CommandExecuter
    {
        private static async Task<IRawResponse> Read(List<ICommand> commands){
            var res = new List<byte> ();
            foreach (var command in commands) {
                res.AddRange(
                    ReadingResponseExtracter.Extract (
                        await CommandTaskManager.Instance.StartCommand (command)
                    )
                );
            }
            return new RawResponseContainer (res.Count > 0, res);
        }
<#
foreach ( var cmd in MetaCommands.Readings) {
#>
        public static async Task<<#= cmd.ReturnValueClass #>> <#= cmd.Title #>(<#= string.Join(", ", cmd.Arguments) #>)
        {
            Log.Debug("CommandExecuter", "<#= cmd.Title #>");
            var res = new <#= cmd.ReturnValueClass #>(await Read(
                new ReadingCommandBuilder(
                    <#= cmd.Address #>,
                    <#= cmd.Data #>
                ).Build(
                    timeOut: <#= cmd.Timeout #>,
                    numOfRetry: <#= cmd.NumOfRetry #>
                )
            ));
            <# if(cmd.Delay > 0){ #>
            await Task.Delay(<#= cmd.Delay #>);
            <# } #>
            return res;
        }
<#  
}
#>

        private static async Task<IRawResponse> Write(ICommand command){
            var res = await CommandTaskManager.Instance.StartCommand (command);
            return new RawResponseContainer(
              WritingResponseExtracter.IsOk (res),
              WritingResponseExtracter.Extract (res)
            );
        }
<#
foreach ( var cmd in MetaCommands.Writings) {
#>
        public static async Task<<#= cmd.ReturnValueClass #>> <#= cmd.Title #>(<#= string.Join(", ", cmd.Arguments) #>)
        {
            Log.Debug("CommandExecuter", "<#= cmd.Title #>");
            var builder = new WritingCommandBuilder(
                <#= cmd.Address #>,
                <#= cmd.Data #>
            );
            var res = new <#= cmd.ReturnValueClass #>(await Write(
                builder.Build(
                    needsResponse: <#= cmd.NeedsResponse.ToString().ToLower() #>,
                    timeout: <#= cmd.Timeout #>,
                    numOfRetry: <#= cmd.NumOfRetry #>
                )
            ));
            <# if(cmd.Delay > 0){ #>
            await Task.Delay(<#= cmd.Delay #>);
            <# } #>
            <# if(cmd.WaitToFinishWriting){ #>
            await WaitToFinishWriting(builder);
            <# } #>
            return res;
        }

<#  
}
#>
    }
}