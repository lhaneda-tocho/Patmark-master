<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<#@ output extension=".designer.cs" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="TokyoChokoku.MarkinBox.Sketchbook.TemplateMeta" #>
<#@ include file="$(SolutionDir)/Global.ttinclude"#>
<#  #>
// 
// This code is generated by "MutableParameterTemplate.tt"
// Not allowed to modify this code because your changes are deleted when in regeration.
// 

namespace TokyoChokoku.MarkinBox.Sketchbook.Parameters {
    using TokyoChokoku.MarkinBox.Sketchbook.Properties.Stores;
    using TokyoChokoku.MarkinBox.Sketchbook.Validators;
    
<#
foreach( var field in MetaFields.Definitions) {
    var parameter = field.Parameter;
    var textValidator = TextValidatorDefinitions.Dictionary.ContainsKey (field) ? 
                        TextValidatorDefinitions.Dictionary [field] : 
                        null;
    var markingValidator = MetaMakingValidator.Create ();
    var geometryValidator = GeometryValidatorDefinitions.Dictionary [field];
#>
	public partial class Mutable<#= parameter.Name #> : IBase<#= parameter.Name #>, IMutableParameter {

        public MarkingValidator MarkingValidator { get; }
<# 
    if (textValidator != null) {
#>
        public <#= textValidator.Name #> TextValidator { get; }
<#
    }
#>
        public <#= geometryValidator.Name #> GeometryValidator { get; }
     
<#
	foreach( var property in parameter.PropertyDefinitions) {
		var storeType = property.StoreTypeName;
		var contentType = property.ContentTypeName;

		var propertyName = property.Name;
		var storeName = propertyName + "Store";
#>

        private <#= contentType #> variable<#= propertyName #>;

        override
        public <#= contentType #> <#= propertyName #> {
            get { return variable<#= propertyName #>;}
            set { variable<#= propertyName #> = value; }
        }
        
		public <#= storeType #> <#= storeName #>
		{ get; }



<#
	}
#>

		public static Mutable<#= parameter.Name #> CopyOf (IBase<#= parameter.Name #> constant) {
			return new Mutable<#= parameter.Name #> (constant);
		}


		public static Mutable<#= parameter.Name #> Create ()
		{
			return new Mutable<#= parameter.Name #> ( <#= parameter.Name #>.Create() );
		}


		public static Mutable<#= parameter.Name #> Create (MBData raw) {
			return new Mutable<#= parameter.Name #> ( <#= parameter.Name #>.Create (raw) );
		}


		/// <summary>
		/// Initializes Stores. 
		/// <see cref="TokyoChokoku.MarkinBox.Sketchbook.Parameters.<#= parameter.Name #>"/> class.
		/// </summary>
		private Mutable<#= parameter.Name #> (
            MBData raw,
<#
	{
		var last = parameter.PropertyDefinitions.Last ();
		foreach( var property in parameter.PropertyDefinitions) {
			var contentType = property.ContentTypeName;
			var propertyName = property.Name;

			if ( !Object.ReferenceEquals (property, last) ) {
#>
			<#= contentType #> <#= propertyName #>,
<#
			} else {
#>
			<#= contentType #> <#= propertyName #> ) : base(raw) {
            
            var validator = <#= field.Name #>Validator.CreateClosed (this);

<#
            if (textValidator != null) {
#>
            TextValidator     = <#= textValidator.Name #>.CreateOf<#= field.Name #> (this);
<#
            }
#>
            MarkingValidator  = <#= markingValidator.Name #>.CreateOf<#= field.Name #> (this);
            GeometryValidator = <#= geometryValidator.Name #>.Create (this);
<#
			}
		}
	}

	{
		foreach( var property in parameter.PropertyDefinitions) {
            var contentType  = property.ContentTypeName;
            var storeType    = property.StoreType;
            var storeName    = property.Name + "Store";

            string validator = "undefined", adjuster = "undefined";
            var categories = property.Categories;

            if (categories.IsNoValidation) {
#>
            variable<#= property.Name #> = <#= property.Name #>;
            <#= storeName #> = new <#= storeType.Name #> (
                EmptyValidator.Validate,
                (     ) => this.<#= property.Name #>,
                (value) => this.<#= property.Name #> = value);
<#
            } else if (categories.Count == 1) {
                if ( categories.OfText ) {
#>
            variable<#= property.Name #> = <#= property.Name #>;
            <#= storeName #> = new <#= storeType.Name #> (
                TextValidator.<#= textValidator.GenValidationMethodName (property) #>,
                (     ) => this.<#= property.Name #>,
                (value) => this.<#= property.Name #> = value);
<#
                } else if ( categories.OfMarking ) {
#>
            variable<#= property.Name #> = <#= property.Name #>;
            <#= storeName #> = new <#= storeType.Name #> (
                MarkingValidator.<#= markingValidator.GenValidationMethodName (property) #>,
                (     ) => this.<#= property.Name #>,
                (value) => this.<#= property.Name #> = value);
<#
                } else if ( categories.OfGeometry ) {
#>
            variable<#= property.Name #> = <#= property.Name #>;
            <#= storeName #> = new <#= storeType.Name #> (
                GeometryValidator.<#= geometryValidator.GenValidationMethodName (property) #>,
                (     ) => this.<#= property.Name #>,
                (value) => this.<#= property.Name #> = value);
<#
                }
            } else {
#>

            variable<#= property.Name #> = <#= property.Name #>;
            <#= storeName #> = new <#= storeType.Name #> (
                (value) => {
                    ValidationResult result = ValidationResult.Empty;
<#
                foreach (var category in categories) {
                    string subValidator, subAdjuster;

                    switch (category) {
                        case ValidationCategory.Text : {

#>
                    result = result.Merge (TextValidator.<#= textValidator.GenValidationMethodName (property) #> (value));
<#
                            break;
                        }
                        case ValidationCategory.Marking : {
#>
                    result = result.Merge (MarkingValidator.<#= markingValidator.GenValidationMethodName (property) #> (value));
<#
                            break;
                        }
                        case ValidationCategory.Geometry : {
#>
                    result = result.Merge (GeometryValidator.<#= geometryValidator.GenValidationMethodName (property) #> (value));
<#
                            break;
                        }
                    }
                }
#>
                    return result;
                },
                (     ) => this.<#= property.Name #>,
                (value) => this.<#= property.Name #> = value);
<#   
            }
#>


<#
		}
	}
#>
            Initialize (validator);
		}


        partial void Initialize (ClosedValidator validator);
		

		/// <summary>
		/// Initializes a new instance by copying the existing instance.
		/// <see cref="TokyoChokoku.MarkinBox.Sketchbook.Parameters.<#= parameter.Name #>"/> class.
		/// </summary>
		/// <param name="copied"> the copied instance. </parm>
		private Mutable<#= parameter.Name #> (IBase<#= parameter.Name #> copied)
			: this (
            copied.raw,
<#
	{
		var last = parameter.PropertyDefinitions.Last ();
		foreach( var property in parameter.PropertyDefinitions) {
			var storeType = property.StoreTypeName;
			var propertyName = property.Name;
			var storeName = propertyName + "Store";
			if ( !Object.ReferenceEquals (property, last) ) {
#>
				copied.<#= propertyName #>,
<#
			} else {
#>
				copied.<#= propertyName #> ) {
		}
<#
			}
		}
	}
#>

        override
		public MBData ToSerializable () {
			return <#= parameter.Name #>.CopyOf (this).ToSerializable ();
		}

	}




<#
}
#>
}