<#@ template language="C#"#>
<#@ assembly name="System.Core" #>
<#@ output extension=".designer.cs" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="TokyoChokoku.MarkinBox.Sketchbook.TemplateMeta" #>
<#@ include file="$(SolutionDir)/Global.ttinclude"#>
<#  #>
// 
// This code is generated by "CommonField.tt"
// Not allowed to modify this code because your changes are deleted when in regeration.
// 


namespace TokyoChokoku.MarkinBox.Sketchbook.Fields {

	using System;
	using System.Collections.Immutable;
	using System.Collections.Generic;

    using TokyoChokoku.MarkinBox.Sketchbook.Parameters;
    using TokyoChokoku.MarkinBox.Sketchbook.Validators;


<#
foreach ( var field in MetaFields.Definitions) {
    var parameter = field.Parameter;
	var changables = field.Changable;
#>
	public abstract partial class <#= field.Name #> : IBaseField <IBase<#= parameter.Name #>> {

		public abstract IBase<#= parameter.Name #> BaseParameter { get; }
		
		private static readonly ISet<FieldType> changeableTypes
<# 	if ( changables.Count == 0 ) {#>
			= ImmutableHashSet.Create<FieldType> ();
<#	
	} else {
#>
			= ImmutableHashSet.Create <FieldType> ( new FieldType[] {
<#
		foreach (var changable in changables) {
#>
				FieldType.<#=changable.Name#>,
<#
		}
#>
			}); // end of channgableTypes
<#
	}
#>


		public FieldType FieldType {
			get {
				return FieldType.<#= field.Name #>;
			}
		}
      
        public static FieldType Type {
            get {
                return FieldType.<#= field.Name #>;
            }
        }
		
		public ISet<FieldType> ChangeableTypes {
			get {
				return changeableTypes;
			}
		}



		public MBData ToSerializable () {
			return BaseParameter.ToSerializable ();
		}


        public ValidationResult Validate () {
            return BaseParameter.Validate ();
        }


		public IField <IConstantParameter> ConvertTo (FieldType type) {
<# 	if ( changables.Count != 0 ) { #>
			switch (type) {
<#
		var last = changables.Last ();
		foreach (var changable in changables) {

			if ( !Object.ReferenceEquals (changable, last) ) {
#>
			case FieldType.<#=changable.Name#>:
				return To<#=changable.Name#> ();
<#
			} else {
#>
			case FieldType.<#=changable.Name#>:
				return To<#=changable.Name#> ();
			}

<#
			}
		}
	}
#>
			throw new FieldTypeExt.NotSupportedTypeException ("");
		}



		public sealed class Constant : <#= field.Name #>, IField <<#= parameter.Name #>> {
			private readonly <#= parameter.Name #> parameter;

			public <#= parameter.Name #> Parameter {
				get { return parameter; }
			}

			override
			public IBase<#= parameter.Name #> BaseParameter {
				get { return parameter; }
			}


			public static Constant Create () {
				return new Constant ( <#= parameter.Name #>.Create () );
			}

			public static Constant Create ( IBase<#= parameter.Name #> parameter ) {
				return new Constant ( <#= parameter.Name #>.CopyOf (parameter) );
			}

			public static Constant Create ( MBData raw ) {
				return new Constant ( <#= parameter.Name #>.Create (raw) );
			}

			public static Constant CopyOf ( <#= field.Name #> field ) {
				return Create ( field.BaseParameter );
			}


			private Constant ( <#= parameter.Name #> parameter ) {
				this.parameter = parameter;
			}

			public Mutable ToMutable () {
				return Mutable.Create (parameter);
			}

			public IMutableField <IMutableParameter> ToGenericMutable () {
				return Mutable.Create (parameter);
			}

			public Return Accept<Return, Argument> (IFieldVisitor <Return,Argument> visitor, Argument arg) {
				return visitor.Visit (this, arg);
			}
		}



		public sealed class Mutable : <#= field.Name #>, IMutableField <Mutable<#= parameter.Name #>> {
			private readonly Mutable<#= parameter.Name #> parameter;

			public Mutable<#= parameter.Name #> Parameter {
				get { return parameter; }
			}

			override
			public IBase<#= parameter.Name #> BaseParameter {
				get { return parameter; }
			}


			public static Mutable Create () {
				return new Mutable ( Mutable<#= parameter.Name #>.Create () );
			}

			public static Mutable Create ( IBase<#= parameter.Name #> parameter ) {
				return new Mutable ( Mutable<#= parameter.Name #>.CopyOf (parameter) );
			}

			public static Mutable CopyOf ( <#= field.Name #> field ) {
				return Create ( field.BaseParameter );
			}

			public static Mutable Create ( MBData raw ) {
				return new Mutable ( Mutable<#= parameter.Name #>.Create (raw) );
			}

			private Mutable ( Mutable<#= parameter.Name #> parameter ) {
				this.parameter = parameter;
			}

			public Constant ToConstant() {
				return Constant.Create (parameter);
			}

			public IField <IConstantParameter> ToGenericConstant () {
				return Constant.Create (parameter);
			}

			public Return Accept<Return, Argument> (IMutableFieldVisitor <Return,Argument> visitor, Argument arg) {
				return visitor.Visit (this, arg);
			}
		}
		

	}




<#
}
#>
}